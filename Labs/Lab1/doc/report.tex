\documentclass[12pt]{article}

\usepackage[margin=1.9cm, letterpaper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{tikz}
\usepackage{float}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{pdfpages}
\usepackage{minted}
\usepackage{fontspec}
\usepackage[style=ieee]{biblatex}
\usepackage{karnaugh-map}

\setmainfont{Noto Serif}
\setsansfont{Segoe UI}
\setmonofont{Consolas}

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \textbf{LAB 1}

        \vspace{0.5cm}

        Implementing Binary Adders in VHDL

        \vspace{1.5cm}

        \textbf{Michael Kwok (1548454)}

        \vfill

        ECE 410 -- Advanced Digital Logic Design\\
        Department of Electrical and Computer Engineering\\
        University of Alberta\\
        October 6, 2021

    \end{center}
\end{titlepage}

\tableofcontents

\pagebreak

\section{Abstract}

In this report, an exploration of two different approaches to digital logic design was done: register-transfer level and structural.
Two different implementations of a 2 bit full adder was made, and the corresponding testbenches.
The VHDL feature of multiple architecture definitions was used to make the testing and implementation easier,
by only needing to select a specific architecture in Vivado instead of editing files.

\section{Design}

\begin{figure}[H]
\centering
\begin{subfigure}{0.3\linewidth}
\begin{karnaugh-map}[4][2][1][$AB$][$C_{in}$]
\minterms{1,2,4,7}
\autoterms[0]
\implicant{1}{1}
\implicant{2}{2}
\implicant{4}{4}
\implicant{7}{7}
\end{karnaugh-map}
\end{subfigure}

\begin{subfigure}{0.3\linewidth}
\begin{karnaugh-map}[4][2][1][$AB$][$C_{in}$]
\minterms{3,5,6,7}
\autoterms[0]
\implicant{3}{7}
\implicant{5}{7}
\implicant{7}{6}
\end{karnaugh-map}
\end{subfigure}
\caption{Karnaugh Maps}
\label{diag:kmap}
\end{figure}

Initially, a truth table for a 1-bit full adder was made (Table \ref{tb:truth-table}).
A corresponding Karnaugh map was subsequently constructed from the values (Figure \ref{diag:kmap}).
As can be seen, $F$ can be constructed by simply getting the exclusive-or summation of the terms, $F = A \oplus B \oplus C$,
and $C_{out}$ can be constructed by minterm implicants: $C_{out} = AB + BC_{in} + AC_{in}$.
For a 2-bit adder, the previous expressions can simply be applied to each bit to form each corresponding output bit, and the $C_{out}$ of the least significant bit must be connected to the $C_{in}$ of the most significant bit.

This circuit was implemented in the RTL level in VHDL, as shown in the code in the appendix.
Two instances of the adder were chained together to produce a ripple-carry 2-bit full adder, which produced a circuit with 3 inputs and 2 outputs: the 2-bit sum and the carry.

\begin{figure}
    \includegraphics{}
\end{figure}


% a. Calculations & Assumptions
% b. Flow Chart 
% c. Truth Table
% d. Synthesized schematic
% e. Board/Implementation (Pin Assignment, On-Board Observations)

\section{Testing \& Simulation}

\section{Conclusion}

\section{References}

\pagebreak
\section{Appendix}

\renewcommand{\thepage}{}

\end{document}
