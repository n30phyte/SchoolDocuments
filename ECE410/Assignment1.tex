\RequirePackage[l2tabu, orthodox]{nag}
\documentclass{article}

\usepackage[letterpaper, margin=1.3cm]{geometry}
\usepackage{siunitx}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{circuitikz}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[outputdir=obj]{minted}

\ctikzset{
    logic ports=ieee,
    logic ports/scale=0.7,
}

\title{ECE 410 Assignment 1}
\author{Michael Kwok}

\begin{document}
\maketitle
\begin{enumerate}
    \item Multicore processors also allow designers to reuse the same core design multiple times and improving overall performance by designing extra ``glue'' circuits allowing said multicores to be used, instead of adding more transistors to the design of the core which might be too much mental load to handle. While the end result will use many more transistors than a single core CPU would, the real ``number'' of transistors that the designer has to worry about would be the number for the singular repeated core plus the glue logic.
    
    This allows the designers to use the entire transistor budget, and providing greater capability for performance to developers and end users. Since there is a thermal limit to how fast a singular core can clock at, having multiple cores come closer to that clock speed can be more beneficial, especially if the workload is parallelizable.
    
    \item The use of photolithography allows the fabrication of multiple transistors at the same time, instead of on a single transistor basis with discrete logic components greatly increases the speed of production for circuits. The ability to mass produce the same circuit quickly and easily after the initial design cost uses the principle of economies of scale, highly reducing the cost per unit.
    
    The shortened paths between components allows the circuit designer to implement logic with higher clocks compared to discrete components and manual wiring where the wire lengths may differ and greatly reduce the timing consistency between components. Since the circuits are created from a single photomask, the results will be incredibly consistent, which increases the reliability of the produced part.
    
    \item \begin{enumerate}
        \item Inverter:
        
        \begin{circuitikz}[]

            \node[nand port](NANDa) at (1,0){};
            \node[left](A) at (0, 0){A};
            \node[right](F) at (2, 0){F};

            \draw (NANDa.in 1) -- (NANDa.in 2);
            \draw (NANDa.in 1 |- NANDa.out) to [short, *-] (A);
            \draw (NANDa.out) -- (F);
         \end{circuitikz}
         \item AND Gate:
         
         \begin{circuitikz}[]
            \node[nand port](NANDa) at (1,0.5){};
            \node[nand port](NANDb) at (3,0.5){};

            \node[left](A) at (0, 1){A};
            \node[left](B) at (0, 0){B};

            \node[right](F) at (4, 0.5){F};

            \draw (NANDb.in 1) -- (NANDb.in 2)
            (NANDb.in 1 |- NANDb.out) to [short, *-] (NANDa.out);
            \draw (NANDb.out) -- (F);
         \end{circuitikz}
         \item OR Gate:

         \begin{circuitikz}[]
            \node[nand port](NANDa) at (1,0.5){};
            \node[nand port](NANDb) at (1,-0.5){};

            \node[nand port](NANDc) at (3,0){};

            \node[left](A) at (0, 0.5){A};
            \node[left](B) at (0, -0.5){B};

            \node[right](F) at (4, 0){F};

            \draw(NANDa.out) -| (NANDc.in 1);
            \draw(NANDb.out) -| (NANDc.in 2);
            
            \draw (NANDa.in 1) -- (NANDa.in 2)
            (NANDa.in 1 |- NANDa.out) to [short, *-] (A);
            \draw (NANDb.in 1) -- (NANDb.in 2)
            (NANDb.in 1 |- NANDb.out) to [short, *-] (B);

            \draw (NANDc.out) -- (F);

         \end{circuitikz}
     \end{enumerate}
     \item
     
     Truth Table:

    \begin{tabular} { c c c }
       \toprule
       \multirow{2}{*}{ABC} & \multicolumn{2}{c}{F} \\
       \cmidrule{2-3}\\
       {} & D = 0 & D = 1 \\
       \midrule
            000 & 1 & 0 \\
            001 & 0 & 1 \\
            010 & 0 & 1 \\
            011 & 1 & 0 \\
            100 & 0 & 1 \\
            101 & 1 & 0 \\
            110 & 1 & 0 \\
            111 & 0 & 1 \\
       \bottomrule
    \end{tabular}

    Circuit:

    \begin{circuitikz}[]
        \node(D) at (0, 3){D};
        \node[muxdemux](MUXa) at (3, 0){MUX 1};
        \node[not port](NOTd) at ($(MUXa.lpin 1) - (1, 0)$){};

        \node(A) at ($(MUXa.bpin 1) - (0, 0.3)$) {A};
        \node(B) at ($(MUXa.bpin 2) - (0, 0.5)$) {B};
        \node(C) at ($(MUXa.bpin 3) - (0, 0.7)$) {C};
        \node(F) at ($(MUXa.rpin 1) + (0.5, 0)$) {F};

        \draw(D) -- (D |- MUXa.lpin 6);
        \draw(D |- NOTd.in) to [short, *-] (NOTd.in);
        \draw(D |- MUXa.lpin 2) to [short, *-] (MUXa.lpin 2);
        \draw(D |- MUXa.lpin 3) to [short, *-] (MUXa.lpin 3);
        \draw(D |- MUXa.lpin 5) to [short, *-] (MUXa.lpin 5);
        \draw(D |- MUXa.lpin 6) to [short, *-] (MUXa.lpin 6);

        \draw(NOTd.out) -- (NOTd.out |- MUXa.lpin 8);
        \draw(NOTd.out |- MUXa.lpin 1) to [short, *-] (MUXa.lpin 1);
        \draw(NOTd.out |- MUXa.lpin 4) to [short, *-] (MUXa.lpin 4);
        \draw(NOTd.out |- MUXa.lpin 7) to [short, *-] (MUXa.lpin 7);
        \draw(NOTd.out |- MUXa.lpin 8) to [short, *-] (MUXa.lpin 8);


        \draw(A) -- (MUXa.bpin 1);
        \draw(B) -- (MUXa.bpin 2);
        \draw(C) -- (MUXa.bpin 3);
        \draw(F) -- (MUXa.rpin 1);

    \end{circuitikz}
    
    \item Truth Table:

    \begin{tabular} { c c c c c c c c c }
        \toprule
        \multirow{2}{*}{$\text{D}_\text{IN}$} & \multicolumn{8}{c}{$\text{D}_\text{OUT}$} \\
        {} & S = 0 & S = 1 & S = 2 & S = 3 & S = 4 & S = 5 & S = 6 & S = 7 \\
        \midrule
        abcdefgh & abcdefgh & habcdefg & ghabcdef & fghabcde & efghabcd & defghabc & cdefghab & bcdefgha \\
        \bottomrule
     \end{tabular}

     Code:

     \begin{minted}{vhdl}
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;

ENTITY BarrelShifter IS
    PORT (
        d_in : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
        d_out : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        rot : IN INTEGER RANGE 0 TO 7
    );
END;

ARCHITECTURE Behavioural OF BarrelShifter IS
BEGIN
    WITH rot SELECT d_out <= 
        d_in WHEN 0, 
        d_in(0) & d_in(7 DOWNTO 1) WHEN 1, 
        d_in(1 DOWNTO 0) & d_in(7 DOWNTO 2) WHEN 2, 
        d_in(2 DOWNTO 0) & d_in(7 DOWNTO 3) WHEN 3, 
        d_in(3 DOWNTO 0) & d_in(7 DOWNTO 4) WHEN 4, 
        d_in(4 DOWNTO 0) & d_in(7 DOWNTO 5) WHEN 5, 
        d_in(5 DOWNTO 0) & d_in(7 DOWNTO 6) WHEN 6, 
        d_in(6 DOWNTO 0) & d_in(7) WHEN 7;
END;
     \end{minted}
     \item Truth Table:

     \begin{tabular} { c c}
         \toprule
         Present State & Next State \\
         \midrule
0000  & 0001 \\
0001  & 0011 \\
0011  & 0010 \\
0010  & 0110 \\
0110  & 0111 \\
0111  & 0101 \\
0101  & 0100 \\
0100  & 1100 \\
1100  & 1101 \\
1101  & 1111 \\
1111  & 1110 \\
1110  & 1010 \\
1010  & 1001 \\
1001  & 1000 \\
1000  & 0000 \\
         \bottomrule
      \end{tabular}
 
      Code:
 
      \begin{minted}{vhdl}
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;

ENTITY GrayCounter IS
    PORT (
        clk : IN STD_LOGIC;
        output : OUT STD_LOGIC_VECTOR(3 DOWNTO 0)
    );
END;

ARCHITECTURE Behavioural OF GrayCounter IS
BEGIN
    PROCESS (clk)
    BEGIN
        IF RISING_EDGE(clk) THEN
            CASE output IS
                WHEN "0000" => 
                    output <= "0001";
                WHEN "0001" => 
                    output <= "0011";
                WHEN "0011" => 
                    output <= "0010";
                WHEN "0010" => 
                    output <= "0110";
                WHEN "0110" => 
                    output <= "0111";
                WHEN "0111" => 
                    output <= "0101";
                WHEN "0101" => 
                    output <= "0100";
                WHEN "0100" => 
                    output <= "1100";
                WHEN "1100" => 
                    output <= "1101";
                WHEN "1101" => 
                    output <= "1111";
                WHEN "1111" => 
                    output <= "1110";
                WHEN "1110" => 
                    output <= "1010";
                WHEN "1010" => 
                    output <= "1001";
                WHEN "1001" => 
                    output <= "1000";
                WHEN "1000" => 
                    output <= "0000";
                WHEN OTHERS => 
                    output <= "0000";
            END CASE;
        END IF;
    END PROCESS;
END ARCHITECTURE;
      \end{minted}

\end{enumerate}
\end{document}
